

/* this file generated by netl */

#include <unistd.h>
#include <stdio.h>
#include <time.h>

#include "netl/global.h"
#include "netl/ether.h"
#include "netl/ip.h"
#include "netl/action.h"
#include "netl/filter.h"
#include "netl/config.h"
#include "netl/io.h"
#include "netl/resolve.h"

struct configlist req;

void log_ip_with_port(u8 *dg, size_t len, char *extra_string, char* logname);
void log_ip_no_port(u8 *dg, size_t len, char *extra_string, char* logname);
void log_non_ip(u8 *dg, size_t len, char *extra_string, char* logname);
void log_ip_unknown(u8 *dg, size_t len, char *extra_string, char* logname);
void log_unknown(u8 *dg, size_t len, char *extra_string, char* logname);
char *dump(u8 *dg, char *logname, size_t len);



/* construct() */

void
construct(void)
{
	addip("starscream", htonl(0x0a0a0a04); /* 10.10.10.4 */ 
	addip("reliant", htonl(0x0a0a0a05); /* 10.10.10.5 */ 
}

/* check() */

void
check(u8 *dg, size_t len)
{
	iphdr *ip = (iphdr *) &dg[14];
	tcphdr *h = (tcphdr *) &dg[(ip->ihl << 2) + 14];
	u8 flags=*(((char *) h) + 13);
	icmphdr *ih = (icmphdr *) &dg[(ip->ihl <<2) + 14];

	/* flags */
	int done_log = 0;
	int done_dump = 0;

	/* PROT_UDP */
	if(
		((machdr*)dg)->type == MACTYPE_IPDG	&&
		ip->version == IP_VERSION		&&
		ip->protocol == PROTOCOL_UDP
	) {
		if(	1 &&
			ntohs(ip->saddr) != 0x0a0a0a04	&& /* "10.10.10.4" */
			1
		) {
			/* ACTION_LOG */
			if(done_log == 0) {
				log_ip_with_port(dg, len, "", "udp_star");
				done_log = 1;
			}
		}
		if(	1 &&
			ntohs(ip->saddr) != 0x0a0a0a02	&& /* "10.10.10.2" */
			1
		) {
			/* ACTION_LOG */
			if(done_log == 0) {
				log_ip_with_port(dg, len, "", "udp_fig");
				done_log = 1;
			}
		}
	}
	/* PROT_TCP */
	if(
		((machdr*)dg)->type == MACTYPE_IPDG	&&
		ip->version == IP_VERSION		&&
		ip->protocol == PROTOCOL_TCP
	) {
		if(	1 &&
			ntohs(ip->saddr) != 0x0a0a0a05	&& /* "10.10.10.5" */
			1
		) {
			/* ACTION_LOG */
			if(done_log == 0) {
				log_ip_with_port(dg, len, "", "tcp_reliant");
				done_log = 1;
			}
		}
		if(	1 &&
			ntohs(ip->saddr) != 0x0a0a0a01	&& /* "10.10.10.1" */
			1
		) {
			/* ACTION_LOG */
			if(done_log == 0) {
				log_ip_with_port(dg, len, "", "tcp_pac");
				done_log = 1;
			}
		}
	}
}


void
log_ip_with_port(u8 *dg, size_t len, char *extra_string, char* logname)
{
	iphdr *ip = (iphdr *) &dg[14];
	tcphdr *t = (tcphdr *) &dg[(ip->ihl << 2) + 14];
	log("%s %s:%d => %s:%d (%s)", logname, 
		ip2string(ip->saddr), ntohs(t->source), 
		ip2string(ip->daddr), ntohs(t->dest), extra_string);
}

void
log_ip_no_port(u8 *dg, size_t len, char *extra_string, char* logname)
{
	iphdr *ip = (iphdr *) &dg[14];
	log("%s %s => %s (%s)", logname, ip2string(ip->saddr), 
			ip2string(ip->daddr), extra_string);
}

void
log_non_ip(u8 *dg, size_t len, char *extra_string, char* logname)
{
	log("%s %02x:%02x:%02x:%02x:%02x:%02x => %02x:%02x:%02x:%02x:%02x:%02x (%s)",
		logname, dg[6], dg[7], dg[8], dg[9], dg[10], dg[11], dg[0], dg[1], dg[2], dg[3], dg[4], dg[5],
                        extra_string);

}

void
log_ip_unknown(u8 *dg, size_t len, char *extra_string, char* logname)
{
	iphdr *ip = (iphdr *) &dg[14];
	if(ip->protocol == PROTOCOL_TCP || ip->protocol == PROTOCOL_UDP)
		log_ip_with_port(dg, len, extra_string, logname);
	else
		log_ip_no_port(dg, len, extra_string, logname);
}

void
log_unknown(u8 *dg, size_t len, char *extra_string, char* logname)
{
	if(((machdr*)dg)->type == MACTYPE_IPDG)
		log_ip_unknown(dg, len, extra_string, logname);
	else
		log_non_ip(dg, len, extra_string, logname);
}

char *
dump(u8 *dg, char *logname, size_t len)
{
	static char	fn[1024];
	static int	sequence=0;
	FILE		*fp;

	if(logname[0] != 0) {
		snprintf(fn, 1024, "/tmp/netl/%s-%d-%d-%d.dg", logname, getpid(), (unsigned) time(NULL), sequence++);
	} else {
		snprintf(fn, 1024, "/tmp/netl/%d-%d-%d.dg", getpid(), (unsigned) time(NULL), sequence++);
	}
	if((fp=fopen(fn, "w"))==NULL) {
		err("unable to open dump file %s", fn);
		return NULL;
	}
	if(fwrite(dg, 1, len, fp) != len)
		err("error writing to dump file %s", fn);
	fclose(fp);

	return fn;
}

