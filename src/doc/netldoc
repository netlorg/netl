#!/usr/bin/perl -w

$version = shift @ARGV;

open(INDEX, '>index.html') || die "unable to write to index.html $!";

#$line = "<P><img src=coreLine.gif alt=
#\"----------------------------------------------------------------------\">
#</P>\n";

print INDEX "
<HTML>
	<HEAD>
		<TITLE>White Dactyl Labs : netl homepage</TITLE>
		<LINK REL=STYLESHEET TYPE=\"text/css\"
			HREF=/css/core.css NAME=core>
	</HEAD>

<BODY>
<h1>netl homepage</h1>

<p><i>netl</i> is a customizable low level network monitor.</p>

<p><i>netl</i> can be configured to look for particular TCP, UDP or ICMP
packets, or can be setup to look for generic IP packets or even raw
ethernet frames.</p>

<p>For example, <i>netl's</i> TCP filters allow individual SYNs and ACKs
(or any combination of flags) to be logged into syslogd or stdout, or
dumped into a file for later perusal.  the companion program <a
href=neta.1.html>neta (1)</a> is used to disassemble those packets in a
human readable form.</p>

<h2>Quickstart</h2>

<p>Netl is a network monitoring utility.  It still has a few rough edges,
but provides functionality which cannot be found in similar programs.  

If you are wondering where to get started, provided with the netl dist is a file called <a
href=netl_install.1.html>INSTALL</a> with a step by step instructions.  Netl has been
developed under the Open Source Linux Operating System, though it should work with anything
which supports the libpcap packet capture library.  We are looking for broader platform
support, espectially under windows.  If you are a programmer and would like to help fee free
to contact us at netl\@netl.org for information.</P>

<p>Netl can now run in one of two different modes.  Interactive mode requires a special netl
user interface.  The only UI written for netl at this time is the perl/Tk netl user
interface, but others are sure to follow.  If you want to play around with the interactive
mode, then you will have to install perl/Tk and <a href=#tk>tknetl</a>.

<p>Daemon mode is the default, and original mode.  Using a <a
href=netl.conf.5.html>config file (usually /etc/netl.conf)</a>, you can
write rules which send packets to syslogd, or get dumped as a file.  You don't need to install anything special to use daemon mode.</a>

<a name=source></a>
<h2>Source code</h2>

<p>The latest version of netl is $version.  For more information on
recent advances in the netl source base, consult the <a
href=HISTORY>HISTORY</a> file.

<ul><li><a href=/netl/netl-$version.tar.gz>netl-$version.tar.gz</a></ul>

<!-- <a name=bin></a>
<h2>Binaries</h2>

<p>We have binary versions available for redhat linux in RPM format.</p>

<TABLE CLASS=dist>

<tr><th>RPM <th>netl version <th>CPU <th>OS <th>os version

<tr><td><a href=/netl/rh61/netl-1.09-1.i386.rpm>netl-1.09-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.1

<tr><td><a href=/netl/rh60/netl-1.09-1.i386.rpm>netl-1.09-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.0

<tr><td><a href=/netl/rh61/netl-1.09-1.alpha.rpm>netl-1.09-1.alpha.rpm</a>
    <td align=center>1.09 <td>alpha <td>Red Hat Linux <td align=center>6.1

</TABLE>

<a name=tk></a>
<h2>Perl/Tk interface</h2>

<p>As a prototype to a more perminent Gtk+ interface for netl, I have
been working on a perl/Tk interface.  If you download the source, the Tk
interface can be built from face/perlTk in the netl dist.  You will need
Perl/Tk 8 or better.  If compiling perl/Tk and the netl perl/Tk interface
sounds like a hassle, considering grabbing one of the binaries:</p>

<TABLE CLASS=dist>
<tr><th>RPM <th>netl version <th>CPU <th>OS <th>os version

<tr><td><a href=/netl/rh61/tknetl-1.09-1.i386.rpm>tknetl-1.09-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.1

<tr><td><a href=/netl/rh60/tknetl-1.09-1.i386.rpm>tknetl-1.09-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.0

<tr><td><a href=/netl/rh61/tknetl-1.09-1.alpha.rpm>tknetl-1.09-1.alpha.rpm</a>
    <td align=center>1.09 <td>alpha <td>Red Hat Linux <td align=center>6.1

</TABLE> 

<p>You will also need perl/Tk, and since Red Hat 6.0 doesn't come with
that, I have also provided that in binary form:</p>

<TABLE CLASS=dist>
<tr><th>RPM <th>netl version <th>CPU <th>OS <th>os version

<tr><td><a href=/netl/rh61/perl-Tk-800.014-1.i386.rpm>perl-Tk-800.014-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.1

<tr><td><a href=/netl/rh60/perl-Tk-800.014-1.i386.rpm>perl-Tk-800.014-1.i386.rpm</a>
    <td align=center>1.09 <td>i386 <td>Red Hat Linux <td align=center>6.0

<tr><td><a href=/netl/rh61/perl-Tk-800.014-1.alpha.rpm>perl-Tk-800.014-1.alpha.rpm</a>
    <td align=center>1.09 <td>alpha <td>Red Hat Linux <td align=center>6.1

</TABLE>

<p>You can also, optionally install perl/Tk yourself (you may have to
provide rpm the `--nodep' option when installing tknetl, if it gives you
problems).  perl/Tk is available at your local CPAN mirror.  See 
<a href=http://www.perl.com>www.perl.com</a> for more details.</p>

-->

<a name=old></a>
<h2>Old versions</h2>

<p>We keep a limited number of older versions of netl available.</p>

<ul>
	<Li><A HREF=/netl/netl-1.09.tar.gz>netl-1.09.tar.gz</A>
	<li><a href=/netl/netl-1.08.tar.gz>netl-1.08.tar.gz</a>
	<li><a href=/netl/netl-1.07.tar.gz>netl-1.07.tar.gz</a>
	<li><a href=/netl/netl-1.05.tar.gz>netl-1.05.tar.gz</a>
	<li><a href=/netl/netl-1.05-1.i386.rpm>netl-1.05-1.i386.rpm</a>
	<li><a href=/netl/netl-1.04.tar.gz>netl-1.04.tar.gz</a>
	<li><a href=/netl/netl-1.04-1.i386.rpm>netl-1.04-1.i386.rpm</a>
	<li><a href=/netl/netl-1.04-1.alpha.rpm>netl-1.04-1.alpha.rpm</a>
	<li><a href=/netl/netl-1.03.tar.gz>netl-1.03.tar.gz</a>
	<li><a href=/netl/netl-1.02.tar.gz>netl-1.02.tar.gz</a>
	<li><a href=/netl/netl-1.01.tar.gz>netl-1.01.tar.gz</a>
</ul>

<a name=doc></a>
<h2>Documentation</h2>

<p>It's best to start out with the main daemon <a
href=netl.8.html>netl(8)</a>, unless you haven't managed to install netl
yet, in which case it's best to start with the <a
href=netl_install.1.html>install guide</a>.  The newest, and most
exciting new features for netl are the new <a
href=netl_module.1.html>netl modules</a> and <a href=netlcc.1.html>netl
compiler</a>.  Modules are considered stable, in fact netl 1.02 and later
are module based.  The compiler is experimental, but useable.</p>

";

$tail_text = "

</BODY></HTML>\n\n";

%sec = ();

for(@ARGV) {
	$filename = $_;
	($root = $filename) =~ s/\.nd//i;
	$root =~ s!^.*/!!g;

	my $title = ''; my $section = 1;  my $header = ''; my $tail = '';  my $line = 0;

	open(FP, $filename) || die "unable to read $filename $!";
	open(TXT, ">$root.txt") || die "unable to write to $root.txt $!";
	open(MAN, ">$root") || die "unable to write to $root";
	open(HTML, ">$root.html") || die "unable to write $root.html";
	$html = '';
	$html_toc = '';
	$section_number = 0;
	$preformated = 0;
	$no_html = 0;

	while(<FP>) {
		chomp;
		$line++;

		if(/^#TITLE (.*)$/) { $title = $1; next }
		if(/^#SECTION (.*)$/) { $section = $1; next }
		if(/^#HEAD (.*)$/) { $header = $1; next }
		if(/^#TAIL (.*)$/) { $tail = $1; next }
		if(/^#EXEC (.*)$/) { $filename = "$1.ind"; $line = 0; open(FP, "$1.ind") || die "unable to open $1.ind $!"; next; }
		if(/^#PRE$/) { $preformated = 1; $html .= "<pre>"; next }
		if(/^#\/PRE$/) { $preformated = 0; $html .= "</pre>"; next }

		if(/^#INCLUDE (.*)$/) {
			open(FRED, $1) || die "unable to read $1 $!";
			print MAN ".nf\n";
			$html .= "\n\n<pre>";
			while(<FRED>) {
				print MAN; print TXT;  
				($tmp47 = $_) =~ s!\&!&amp;!g;
				$tmp47 =~ s!\<!&lt;!g;
				$html .= $tmp47;
			}
			$html .= "</pre>\n\n";
			print MAN ".fi\n";
			next;
		}

		if(/^#START/) {
			print MAN ".ad b
.TH $title $section \"$tail\" \"$header\" \"$header\"
.AT 3
.de sh
.br
.ne 5
.PP
\\fB\\\\\$1\\fR
.PP
..\n";
			print HTML "
<HTML>
	<HEAD>
		<TITLE>$header : $title($section)</TITLE>
		<LINK REL=STYLESHEET TYPE=\"text/css\"
			HREF=/css/core.css NAME=core>
	</HEAD>
<body>
<h1>$header : $title($section)</h1>\n";
			print TXT "$title\($section\)
$header
$tail";

			next;
		}

		if(/^#NO (.*)$/) {
			if($1 eq 'MAN') {
				close MAN;
				unlink "$root";
				open(MAN, ">/dev/null");
			} elsif($1 eq 'TXT') {
				close TXT;
				unlink "$root.txt";
				open(MAN, ">/dev/null");
			} elsif($1 eq 'HTML') {
				$no_html = 1;
			}
			next;
		}

		if(/^#H (.*)$/) {
			print MAN ".SH $1\n";
			print TXT "\n$1\n";
			$section_number++;
			$html .= "<a name=sec$section_number><h2>$1</h2>\n\n";
			$html_toc .= "  <li><a href=#sec$section_number>$1</a>\n";
			if($1 eq 'NAME') {
				#print INDEX "  <li><a href=$root.html>$title($section)</a>\n";
				$go_name = 1;
			}
			next;
		}

		if(/^#ALSOAS (.*)\((\d)\)$/) {
			open(ALSO, ">$1.$2") || die "unable to open $1.$2";
			print ALSO ".so man$section/$title.$section\n";
			close ALSO;
			next;
		}

		warn "$filename:$line:unknown directive" if /^#/;
		s/^hash#/#/;

		if($_ eq '') {
			print MAN ".PP\n";
			print TXT "\n";
			$html .= "<p>\n";
			next;
		}

		($man = $_) =~ s/i\<(.*?)\>\s*/\n.I $1\n/mg;
		$man =~ s/b\<(.*?)\>\s*/\n.B $1\n/mg;
		$man =~ s/sa\<(.*?)\>\((.*?)\)(\S*)\s*/\n.BR $1 ($2)$3\n/mg;
		($tmp = $_) =~ s!i\<(.*?)\>\s*! <i>$1</i> !mg;
		$tmp =~ s!b\<(.*?)\>\s*! <b>$1</b> !mg;
		$tmp =~ s!sa\<(.*?)\>\((.*?)\)\s*! <a href=$1.$2.html>$1 ($2)</a> !mg;
		$tmp =~ s!\b(http://.*?)\s!<a href=$1>$1</a>!mg;
		($txt = $_) =~ s/[ib]\<(.*?)\>/$1/mg;
		$txt =~ s/sa\<(.*?)\>/$1/mg;

		chomp($man);
		$man =~ s/^\n//gm;
		$html .= "$tmp\n";


		warn "$filename:$line:newline" if $_ =~ /\n/m;
		warn "$filename:$line:blank" if $_ eq '';

		print MAN "$man\n";
		print MAN ".br\n" if $preformated;
		print TXT "$txt\n";
		if($go_name) {
			($tmp2 = $tmp) =~ s/^.*?-//;
			#print INDEX "$tmp2\n";
			$go_name = 0;
		}
	}

	$sec{$section} = [ ]
		unless defined $sec{$section};
	push @{ $sec{$section} }, [ "$root.html", "$title", "$tmp2" ];

	print HTML "<h2>table of content</h2>\n<ul>\n$html_toc\n</ul>\n$html\n$tail_text";
}

print INDEX "<UL>\n";

foreach my $section (sort { $a <=> $b } keys %sec) {
	print INDEX "<LI>Section $section\n";

	print INDEX "User Programs" if $section == 1;
	print INDEX "Application Programmer Interface (somewhat incomplete) " if $section == 3;
	print INDEX "File Formats" if $section == 5;
	print INDEX "Daemons and Services" if $section == 8;

	print INDEX "<UL>\n";
	for(@{ $sec{$section} }) {
		my($url, $title, $desc) = @{ $_ };
		print INDEX "<LI><A HREF=$url>$title($section)</A>$desc</LI>\n";
	}
	print INDEX "</UL></LI>\n";
}

print INDEX "</UL>

<a name=contact></a>
<h2>Contact</h2>

<p>You can contact the netl team at <a
href=mailto:netl\@netl.org>netl\@netl.org</a>.</P>";


print INDEX "$tail_text";
